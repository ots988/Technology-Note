SE主要用于桌面程序,控制台开发(JFC)
EE企业级开发(JSP,EJB)
ME嵌入式开发(手机,小家电)  

经常有同学会在.NET、C#和ASP.NET这三者之间区别不清楚，到底它们之间有什么联系呢？在这里我给大家归纳如下：

1、.NET是一个平台，一个抽象的平台的概念。

   .NET平台其本身实现的方式其实还是库，抽象层面上来看是一个平台。

   本人理解的.NET核心就是.NET Framwork。

   .NET Framework包括两个关键组成元素：

		   a.Common Language Runtime，公共语言运行时（CLR）-提供内在管理，代码安全性检测等功能

		   b..NET Framework Class Library，.NET框架类库（FLC）-提供大量应用类库，提高开发效率　　

   学习.NET Framework 是所有.NET 开发人员都必须的，否则开发.NET程序永远都是停留在‘外功’的招式，NET Framework 是.NET开发高手的‘内功’修行之一。　

2、C#是一个程序设计语言，仅仅是一个语言。　　

	程序设计语言仅仅是为了方便开发人员和计算机沟通的工具，虽然C#语法相对C和C++要多一些，但是相对来看C#语法都比较固定，这样使用起来却都很容易。我认可一位朋友说的，C#的语法更严谨！　　

	这里回过来看看.NET和C#的关系，不得不提的是.NET程序的执行过程。　　

	C#符合.NET CLR中的公共语言运行规范。CLS:common language specification，当然所有的.NET Language都是符合这个规范的例如：VB.NET、XAML和C++/CLI....等等。　　

	C#需要符合.NET CLS，是因为.NET CLR和JAVA 虚拟机类似，有一个中间语言共机器来执行。所有不同语言的.NET代码在执行前会被编译成同样的中间语言(MSIL)，所以所有.NET支持语言都必须符合符合CLS规范。　　

	P.S：如果做.NET 3.0 XAML开发的朋友，可以尝试下ildasm.exe看看XAML的应用程序，会发现原来XAML其实很简单。 　

3、ASP.NET是一个网站开发的技术，仅仅是.NET框架中的一个应用模型。　　

	用微软公司ASP.NET快速入门中的一句话来解释，ASP.NET 是用于生成基于Web的应用程序的内容丰富的编程框架。


java笔试题多做
多写多读代码，遇到问题不能努力解决，自己总归有错
设计模式
搞清spring rest风格
spring 配置文件详解
jvm内存原理
java 语法格式错误，疑难点纠正
基础api
数据库：结构，nosql，
imooc上看设计模式
编程艺术
性能优化
java抱死
解决问题的编程思路，对语言的理解


按键精灵
mmv--mvc的扩展
查阅github，发现感兴趣的资源
数量多用队列和缓存
zbus
AWT组件
java build path 详解
Apache
abstract
实参和形参
字面量
++ --
Executor框架来创建线程池
java编程的联系还是要放在实战中
jvm 线程日志 怎么看错误输出
github
内存
用虚拟机有什么好处
Queue
静态方法内部，只能用静态成员
HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。
PriorityQueue是一个基于优先级堆的无界队列，优先队列不允许空值，而且不支持non-comparable（不可比较）的对象
队列是遵循先进先出  
serializable
实现hashCode()和equals()方法
序列化
AOP
transient 
1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。
3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。
volatile 已经读了就固定了  保证可见性和禁止指令重排序
使用volatile必须具备以下2个条件：
1）对变量的写操作不依赖于当前值
2）该变量没有包含在具有其他变量的不变式中
寄存器
hashCode和equals
Socket和ServerSocket
zai和堆
wait和sleep的区别
enum 枚举
接口的属性都是公共的,静态的,最终的
API查阅
IETester
installanywhere
关于JVM内存管理的一些建议
1、手动将生成的无用对象，中间对象置为null，加快内存回收。
2、对象池技术如果生成的对象是可重用的对象，只是其中的属性不同时，可以考虑采用对象池来较少对象的生成。如果有空闲的对象就从对象池中取出使用，没有再生成新的对象，大大提高了对象的复用率。
3、JVM调优通过配置JVM的参数来提高垃圾回收的速度，如果在没有出现内存泄露且上面两种办法都不能保证JVM内存回收时，可以考虑采用JVM调优的方式来解决，不过一定要经过实体机的长期测试，因为不同的参数可能引起不同的效果。如-Xnoclassgc参数等。
java.lnag.Object中对hashCode的约定：
   1. 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。
   2. 如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。
   3. 如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。

修饰符顺序
三种类的修饰符
public、abstract、final
三种构造函数的修饰符
public、protected、private
七种实例变量的修饰符
public、protected、private、static、final、transient、volatile
一种局部变量的修饰符
final
八种方法的修饰符
public、protected、private、static、final、abstract、native、synchronized

工作：
1.提问问员工以前做过什么培训，比抽象得问做过什么培训更好
2.

svg：
1.图层
2.一般用钢笔画
3.删除原有图层，不闭合有异常
4.文档颜色用CMYK

js：
闭包，，内存溢出
原型和prot 分开，改动prototype的影响


wikipedia

3、除了阅读和项目相关的书外，还会阅读IT行业的书，比如学Java时，还会去了解函数语言，如LISP。 
4、找一些开源项目看看，大量试用第三方框架，还会写写demo。 
5、阅读基础框架、J2EE规范、Debug服务器内核
源码阅读：
可以从JDK的工具包开始，也就是我们学的《数据结构和算法》Java版 数组，排序
然后是core包，也就是String、StringBuffer等。 
如果你有一定的Java IO基础，那么不妨读读FileReader等类。我建议大家看看《Java In A Nutshell》，里面有整个Java IO的架构图。Java IO类库，如果不理解其各接口和继承关系，则阅读始终是一头雾水。 
Java IO 包，我认为是对继承和接口运用得最优雅的案例。如果你将来做架构师，你一定会经常和它打交道，如项目中部署和配置相关的核心类开发。 

读这些源码时，只需要读懂一些核心类即可，如和ArrayList类似的二三十个类，对于每一个类，也不一定要每个方法都读懂。像String有些方法已经到虚拟机层了(native方法)，如hashCode方法。 

当然，如果有兴趣，可以对照看看JRockit的源码，同一套API，两种实现，很有意思的。 
如果你再想钻的话，不妨看看针对虚拟机的那套代码，如System ClassLoader的原理，它不在JDK包里，JDK是基于它的。JDK的源码Zip包只有10来M，它像是有50来M，Sun公司有下载的，不过很隐秘。 

Java Web开发源码 
在阅读Tomcat等源码前，一定要有一定的积累。我的切实体会，也可以说是比较好的阶梯是： 
1、写过一些Servlet和JSP代码。注意，不是用什么Struts，它是很难接触到Servlet精髓的。用好Struts只是皮毛。
2、看过《Servlet和JSP核心编程》 
3、看过Sun公司的Servlet规范 
4、看过http协议的rfc，debug过http的数据包 
如果有以上基础，我也不建议你开始读Tomcat源码。我建议你在阅读Tomcat源码前，读过Struts源码，Struts源码比WebWork要简单得多。这个框架是可以100%读懂的，至少WebWork我没有100%读懂。我曾经因为读懂了Struts源码，自己写过一个Web框架。 

当然，在读Struts框架前，最好看过它的MailReader等demo，非常非常不错的。  
在读Struts前，建议看看mvnforum的源码，它部分实现了Struts的功能，虽然这个BBS做得不敢恭维。 

如果你读过Struts，再开始考虑Tomcat源码阅读吧。 
不过，我还是不建议直接读它，先读读onJava网站上的系列文章《How Tomcat Works》吧，它才是Tomcat的最最简易版。它告诉你HttpServletRequest如何在容器内部实现的，Tomcat如何通过Socket来接受外面的请求，你的Servlet代码如何被Tomcat容器调用的(回调)。 
学习JSP，一定要研读容器将JSP编译后的Servlet源码。 
为什么我总是称呼Tomcat为容器，而不是服务器？这个疑问留给大家吧。 

如果你一定要读Tomcat，那么就读Jetty吧。至少它是嵌入式，可以直接在eclispe里面设置断点debug。虽然Tomcat也有嵌入式版本。 

Java数据库源码阅读 
我建议，先读读Sun的JDBC规范。 
我想你一定写过JDBC的代码，那么这时候可以开始阅读源码了。 
如果了解JDBC规范(接口)，那么它的实现，JDBC Driver就一定要开始了解，我的建议是，读读mysql的jdbc驱动，因为它开源、设计优雅。在读mysql的JDBC驱动源码时，建议看看mysql的内幕，官方正好有本书，《Mysql Internals》，我五年前读过一部分。比如你可以知道mysql的JDBC驱动，如何通过socket数据包(connect、query)，给这个C++开发的mysql服务器交互的。 

通过上面的阅读，你可以知道，你的业务代码、JDBC规范、JDBC驱动、以及数据库，它们是如何一起协作的。 
如果你了解这些内幕，那么你再学习Hibernate、iBatis等持久化框架时，就会得心应手的。 

读过JDBC驱动，那么下一步一定要读读数据库了。而正好有一个强大的数据库是用Java开发的，Hsqldb。它是嵌入式数据库，比如用在桌面客户端软件里，如Mail Client。 


Java通讯及客户端软件 
我强烈推荐即时通讯软件wildfire和Spark。你可以把wildfire理解成MSN服务器，Spark理解成MSN客户端。它们是通过XMPP协议通讯的。 
我曾经在一个项目中，定制过Spark，当然也包括服务端的一些改动。所以它们的源码我都读过。 
我之所以推荐它们。是因为： 
1、XMPP够轻量级，好理解 
2、学习Socket通讯实现，特别是C/S架构设计 
3、模块化设计。它们都是基于module的，你既可以了解模块化架构，还可以了解模块化的技术支撑：Java虚拟机的ClassLoader的应用场景。 
4、Event Driven架构。虽然GUI都是Event驱动的，但Spark的设计尤其优雅 

Java企业级应用 
当然了，就是Hibernate、Spring这类框架。 
在读Spring源码前，一定要先看看Rod Johnson写的那边《J2EE Design and Development》，它是Spring的设计思路。注意，不是中文版。 
在读Hibernate源码前，一定要读读Gavin King写的那本《Hibernate in Action》，同时，应该再读读Martin Fowler写的《企业应用架构模式》，它专门谈到持久化框架的设计思路。当你觉得这两本书读透了,再去看它们源码吧。 
而且，在读源码前，你会发现它们用到很多第三方Jar包，二三十个，你最好把那些Jar包先一个个搞明白。 

说到企业应用，一定会涉及到工作流。我当年读过jBPM的源码，网上有介绍jBPM内核的文章(银狐)。我感觉它的内核也就两千行，不要害怕。我曾经阅读jBPM源码的博客。 
当然了，读工作流源码，前提是一定要对其理论模型有深入的了解，以及写过一些demo、或做过一些项目 

我上面介绍的这些，是我自己读过的，也适合一般人阅读。 

我也读过一些非Java源码，感觉不错，也推荐给大家： 

Flex源码 Flex 08年底刚刚开源后，我就用它做过一个中型项目，应该说是国内的技术先行者。当时市面没有有深度的书，也没有开源项目。我纯粹是看Flex的Help文档和源码，把项目搞定的。两三年过去了，现在觉得系统设计得蛮优雅的。 

实例域对应的英文应该是Object field， 也就是我们常说的类的字段，或者说是类的属性

构造器而言，它只能够被调用，而不能被继承
对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。

若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。

在实现多接口的时候一定要避免方法名的重复

使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。

      2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。

      3、创建内部类对象的时刻并不依赖于外围类对象的创建。

      4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。

      5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。


内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）

第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类
匿名内部类
1、 匿名内部类是没有访问修饰符的。

2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。

3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。

4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法
