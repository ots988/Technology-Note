SE主要用于桌面程序,控制台开发(JFC)
EE企业级开发(JSP,EJB)
ME嵌入式开发(手机,小家电)  

经常有同学会在.NET、C#和ASP.NET这三者之间区别不清楚，到底它们之间有什么联系呢？在这里我给大家归纳如下：

1、.NET是一个平台，一个抽象的平台的概念。

   .NET平台其本身实现的方式其实还是库，抽象层面上来看是一个平台。

   本人理解的.NET核心就是.NET Framwork。

   .NET Framework包括两个关键组成元素：

		   a.Common Language Runtime，公共语言运行时（CLR）-提供内在管理，代码安全性检测等功能

		   b..NET Framework Class Library，.NET框架类库（FLC）-提供大量应用类库，提高开发效率　　

   学习.NET Framework 是所有.NET 开发人员都必须的，否则开发.NET程序永远都是停留在‘外功’的招式，NET Framework 是.NET开发高手的‘内功’修行之一。　

2、C#是一个程序设计语言，仅仅是一个语言。　　

	程序设计语言仅仅是为了方便开发人员和计算机沟通的工具，虽然C#语法相对C和C++要多一些，但是相对来看C#语法都比较固定，这样使用起来却都很容易。我认可一位朋友说的，C#的语法更严谨！　　

	这里回过来看看.NET和C#的关系，不得不提的是.NET程序的执行过程。　　

	C#符合.NET CLR中的公共语言运行规范。CLS:common language specification，当然所有的.NET Language都是符合这个规范的例如：VB.NET、XAML和C++/CLI....等等。　　

	C#需要符合.NET CLS，是因为.NET CLR和JAVA 虚拟机类似，有一个中间语言共机器来执行。所有不同语言的.NET代码在执行前会被编译成同样的中间语言(MSIL)，所以所有.NET支持语言都必须符合符合CLS规范。　　

	P.S：如果做.NET 3.0 XAML开发的朋友，可以尝试下ildasm.exe看看XAML的应用程序，会发现原来XAML其实很简单。 　

3、ASP.NET是一个网站开发的技术，仅仅是.NET框架中的一个应用模型。　　

	用微软公司ASP.NET快速入门中的一句话来解释，ASP.NET 是用于生成基于Web的应用程序的内容丰富的编程框架。


java笔试题多做
多写多读代码，遇到问题不能努力解决，自己总归有错
设计模式
搞清spring rest风格
spring 配置文件详解
jvm内存原理
java 语法格式错误，疑难点纠正
基础api
数据库：结构，nosql，
imooc上看设计模式
编程艺术
性能优化
java抱死
解决问题的编程思路，对语言的理解


按键精灵
mmv--mvc的扩展
查阅github，发现感兴趣的资源
数量多用队列和缓存
zbus
AWT组件
java build path 详解
Apache
abstract
实参和形参
字面量
++ --
Executor框架来创建线程池
java编程的联系还是要放在实战中
jvm 线程日志 怎么看错误输出
github
内存
用虚拟机有什么好处
Queue
静态方法内部，只能用静态成员
HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。
PriorityQueue是一个基于优先级堆的无界队列，优先队列不允许空值，而且不支持non-comparable（不可比较）的对象
队列是遵循先进先出  
serializable
实现hashCode()和equals()方法
序列化
AOP
transient 
1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。
2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。
3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。
volatile 已经读了就固定了  保证可见性和禁止指令重排序
使用volatile必须具备以下2个条件：
1）对变量的写操作不依赖于当前值
2）该变量没有包含在具有其他变量的不变式中
寄存器
hashCode和equals
Socket和ServerSocket
zai和堆
wait和sleep的区别
enum 枚举
接口的属性都是公共的,静态的,最终的
API查阅
IETester
installanywhere
关于JVM内存管理的一些建议
1、手动将生成的无用对象，中间对象置为null，加快内存回收。
2、对象池技术如果生成的对象是可重用的对象，只是其中的属性不同时，可以考虑采用对象池来较少对象的生成。如果有空闲的对象就从对象池中取出使用，没有再生成新的对象，大大提高了对象的复用率。
3、JVM调优通过配置JVM的参数来提高垃圾回收的速度，如果在没有出现内存泄露且上面两种办法都不能保证JVM内存回收时，可以考虑采用JVM调优的方式来解决，不过一定要经过实体机的长期测试，因为不同的参数可能引起不同的效果。如-Xnoclassgc参数等。
java.lnag.Object中对hashCode的约定：
   1. 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。
   2. 如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。
   3. 如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。

修饰符顺序
三种类的修饰符
public、abstract、final
三种构造函数的修饰符
public、protected、private
七种实例变量的修饰符
public、protected、private、static、final、transient、volatile
一种局部变量的修饰符
final
八种方法的修饰符
public、protected、private、static、final、abstract、native、synchronized

工作：
1.提问问员工以前做过什么培训，比抽象得问做过什么培训更好
2.

svg：
1.图层
2.一般用钢笔画
3.删除原有图层，不闭合有异常
4.文档颜色用CMYK

js：
闭包，，内存溢出
原型和prot 分开，改动prototype的影响


wikipedia

3、除了阅读和项目相关的书外，还会阅读IT行业的书，比如学Java时，还会去了解函数语言，如LISP。 
4、找一些开源项目看看，大量试用第三方框架，还会写写demo。 
5、阅读基础框架、J2EE规范、Debug服务器内核
源码阅读：
可以从JDK的工具包开始，也就是我们学的《数据结构和算法》Java版 数组，排序
然后是core包，也就是String、StringBuffer等。 
如果你有一定的Java IO基础，那么不妨读读FileReader等类。我建议大家看看《Java In A Nutshell》，里面有整个Java IO的架构图。Java IO类库，如果不理解其各接口和继承关系，则阅读始终是一头雾水。 
Java IO 包，我认为是对继承和接口运用得最优雅的案例。如果你将来做架构师，你一定会经常和它打交道，如项目中部署和配置相关的核心类开发。 

读这些源码时，只需要读懂一些核心类即可，如和ArrayList类似的二三十个类，对于每一个类，也不一定要每个方法都读懂。像String有些方法已经到虚拟机层了(native方法)，如hashCode方法。 

当然，如果有兴趣，可以对照看看JRockit的源码，同一套API，两种实现，很有意思的。 
如果你再想钻的话，不妨看看针对虚拟机的那套代码，如System ClassLoader的原理，它不在JDK包里，JDK是基于它的。JDK的源码Zip包只有10来M，它像是有50来M，Sun公司有下载的，不过很隐秘。 

Java Web开发源码 
在阅读Tomcat等源码前，一定要有一定的积累。我的切实体会，也可以说是比较好的阶梯是： 
1、写过一些Servlet和JSP代码。注意，不是用什么Struts，它是很难接触到Servlet精髓的。用好Struts只是皮毛。
2、看过《Servlet和JSP核心编程》 
3、看过Sun公司的Servlet规范 
4、看过http协议的rfc，debug过http的数据包 
如果有以上基础，我也不建议你开始读Tomcat源码。我建议你在阅读Tomcat源码前，读过Struts源码，Struts源码比WebWork要简单得多。这个框架是可以100%读懂的，至少WebWork我没有100%读懂。我曾经因为读懂了Struts源码，自己写过一个Web框架。 

当然，在读Struts框架前，最好看过它的MailReader等demo，非常非常不错的。  
在读Struts前，建议看看mvnforum的源码，它部分实现了Struts的功能，虽然这个BBS做得不敢恭维。 

如果你读过Struts，再开始考虑Tomcat源码阅读吧。 
不过，我还是不建议直接读它，先读读onJava网站上的系列文章《How Tomcat Works》吧，它才是Tomcat的最最简易版。它告诉你HttpServletRequest如何在容器内部实现的，Tomcat如何通过Socket来接受外面的请求，你的Servlet代码如何被Tomcat容器调用的(回调)。 
学习JSP，一定要研读容器将JSP编译后的Servlet源码。 
为什么我总是称呼Tomcat为容器，而不是服务器？这个疑问留给大家吧。 

如果你一定要读Tomcat，那么就读Jetty吧。至少它是嵌入式，可以直接在eclispe里面设置断点debug。虽然Tomcat也有嵌入式版本。 

Java数据库源码阅读 
我建议，先读读Sun的JDBC规范。 
我想你一定写过JDBC的代码，那么这时候可以开始阅读源码了。 
如果了解JDBC规范(接口)，那么它的实现，JDBC Driver就一定要开始了解，我的建议是，读读mysql的jdbc驱动，因为它开源、设计优雅。在读mysql的JDBC驱动源码时，建议看看mysql的内幕，官方正好有本书，《Mysql Internals》，我五年前读过一部分。比如你可以知道mysql的JDBC驱动，如何通过socket数据包(connect、query)，给这个C++开发的mysql服务器交互的。 

通过上面的阅读，你可以知道，你的业务代码、JDBC规范、JDBC驱动、以及数据库，它们是如何一起协作的。 
如果你了解这些内幕，那么你再学习Hibernate、iBatis等持久化框架时，就会得心应手的。 

读过JDBC驱动，那么下一步一定要读读数据库了。而正好有一个强大的数据库是用Java开发的，Hsqldb。它是嵌入式数据库，比如用在桌面客户端软件里，如Mail Client。 


Java通讯及客户端软件 
我强烈推荐即时通讯软件wildfire和Spark。你可以把wildfire理解成MSN服务器，Spark理解成MSN客户端。它们是通过XMPP协议通讯的。 
我曾经在一个项目中，定制过Spark，当然也包括服务端的一些改动。所以它们的源码我都读过。 
我之所以推荐它们。是因为： 
1、XMPP够轻量级，好理解 
2、学习Socket通讯实现，特别是C/S架构设计 
3、模块化设计。它们都是基于module的，你既可以了解模块化架构，还可以了解模块化的技术支撑：Java虚拟机的ClassLoader的应用场景。 
4、Event Driven架构。虽然GUI都是Event驱动的，但Spark的设计尤其优雅 

Java企业级应用 
当然了，就是Hibernate、Spring这类框架。 
在读Spring源码前，一定要先看看Rod Johnson写的那边《J2EE Design and Development》，它是Spring的设计思路。注意，不是中文版。 
在读Hibernate源码前，一定要读读Gavin King写的那本《Hibernate in Action》，同时，应该再读读Martin Fowler写的《企业应用架构模式》，它专门谈到持久化框架的设计思路。当你觉得这两本书读透了,再去看它们源码吧。 
而且，在读源码前，你会发现它们用到很多第三方Jar包，二三十个，你最好把那些Jar包先一个个搞明白。 

说到企业应用，一定会涉及到工作流。我当年读过jBPM的源码，网上有介绍jBPM内核的文章(银狐)。我感觉它的内核也就两千行，不要害怕。我曾经阅读jBPM源码的博客。 
当然了，读工作流源码，前提是一定要对其理论模型有深入的了解，以及写过一些demo、或做过一些项目 

我上面介绍的这些，是我自己读过的，也适合一般人阅读。 

我也读过一些非Java源码，感觉不错，也推荐给大家： 

Flex源码 Flex 08年底刚刚开源后，我就用它做过一个中型项目，应该说是国内的技术先行者。当时市面没有有深度的书，也没有开源项目。我纯粹是看Flex的Help文档和源码，把项目搞定的。两三年过去了，现在觉得系统设计得蛮优雅的。 

实例域对应的英文应该是Object field， 也就是我们常说的类的字段，或者说是类的属性

构造器而言，它只能够被调用，而不能被继承
对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。

若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。

在实现多接口的时候一定要避免方法名的重复

使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。

      2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。

      3、创建内部类对象的时刻并不依赖于外围类对象的创建。

      4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。

      5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。


内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）

第一：成员内部类中不能存在任何static的变量和方法；第二：成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类
匿名内部类
1、 匿名内部类是没有访问修饰符的。

2、 new 匿名内部类，这个类首先是要存在的。如果我们将那个InnerClass接口注释掉，就会出现编译出错。

3、 注意getInnerClass()方法的形参，第一个形参是用final修饰的，而第二个却没有。同时我们也发现第二个形参在匿名内部类中没有使用过，所以当所在方法的形参需要被匿名内部类使用，那么这个形参就必须为final。

4、 匿名内部类是没有构造方法的。因为它连名字都没有何来构造方法

如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的

静态代码块就是用static修饰的用{}括起来的代码段，它的主要目的就是对静态属性进行初始化。

同步代码块    使用 synchronized 关键字修饰，并使用“{}”括起来的代码片段，它表示同一时间只能有一个线程进入到该方法块中，是一种多线程保护机制

构造代码不是在构造函数之前运行的，它是依托构造函数执行的


equals 方法在非空对象引用上实现相等关系：

      1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。

      2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。

      3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。

      4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。

      5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。

       对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。

       在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：

      1) 对象域，使用equals方法 。
       2) 类型安全的枚举，使用equals或== 。
       3) 可能为null的对象域 : 使用 == 和 equals 。
       4) 数组域 : 使用 Arrays.equals 。
       5) 除float和double外的原始数据类型 : 使用 == 。
       6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。
       7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==
	   
 
		在某些特殊的情况下，String字符串的拼接会被JVM解析成StringBuilder对象拼接，在这种情况下String的速度比StringBuffer的速度快。如：

      String name = ”I ” + ”am ” + ”chenssy ” ;

      StringBuffer name = new StringBuffer(”I ”).append(” am ”).append(” chenssy ”);

      对于这两种方式，你会发现第一种比第二种快太多了，在这里StringBuffer的优势荡然无存。其真实的原因就在于JVM做了一下优化处理，其实String name = ”I ” + ”am ” + ”chenssy ” ;在JVM眼中就是String name = ”I am chenssy ” ;这样的方式对于JVM而言，真的是不要什么时间。但是如果我们在这个其中增加一个String对象，那么JVM就会按照原来那种规范来构建String对象了。

	  在多线程的环境中，则可以考虑使用StringBuffer，例如XML解析、HTTP参数解析和封装等。SQL语句的拼装、JSON封装等
		
		append()速度最快，concat()次之，+最慢
		
		
对于编译期常量，只能使用基本类型，而且必须要在定义时进行初始化

final方法使用的第一个原因就是方法锁定，以防止任何子类来对它的修改。至于第二个原因就是效率问题，鄙人对这个效率问题理解的不是很清楚，在网上摘抄这段话：在java的早期实现中，如果将一个方法指明为final，就是同意编译器将针对该方法的所有调用都转为内嵌调用。当编译器发现一个final方法调用命令时，它会根据自己的谨慎判断，跳过插入程序代码这种正常的调用方式而执行方法调用机制（将参数压入栈，跳至方法代码处执行，然后跳回并清理栈中的参数，处理返回值），并且以方法体中的实际代码的副本来代替方法调用。这将消除方法调用的开销。当然，如果一个方法很大，你的程序代码会膨胀，因而可能看不到内嵌所带来的性能上的提高，因为所带来的性能会花费于方法内的时间量而被缩减。

 如果某个类用final修改，表明该类是最终类，它不希望也不允许其他来继承它。在程序设计中处于安全或者其他原因，我们不允许该类存在任何变化，也不希望它有子类，这个时候就可以使用final来修饰该类了。

对于final修饰的类来说，它的成员变量可以为final，也可以为非final。如果定义为final，那么final数据的规则同样适合它。而它的方法则会自动的加上final，因为final类是无法被继承，所以这个是默认的。
       四、 final参数

       在实际应用中，我们除了可以用final修饰成员变量、成员方法、类，还可以修饰参数、若某个参数被final修饰了，则代表了该参数是不可改变的。
	   
	   //p = new Person();    --final参数不可变 
	   
	   同final修饰参数在内部类中是非常有用的，在匿名内部类中，为了保持参数的一致性，若所在的方法的形参需要被内部类里面使用时，该形参必须为final。
	   
1）形参为基本类型时，对形参的处理不会影响实参。
2）形参为引用类型时，对形参的处理会影响实参。
3）String,Integer,Double等immutable类型的特殊处理，可以理解为值传递，形参操作不会影响实参对象。

若程序中显示的声明了某个异常，则抛出异常时不会显示出处，若程序中没有显示的声明某个异常，当抛出异常时，系统会显示异常的出处

public void g() throws MyException{  
        try {  
            f();  
        } catch (MyException e) {  
            //e 保存异常信息  
            throw new MyException("文件没有找到--02",e);  
        }  
    }  
	没有e就无法建造异常链
	尽可能的减小try块，精确定位错误
	不要在finally块中处理返回值。
    七、不要在构造函数中抛出异常。
	1、处理异常。对所发生的的异常进行一番处理，如修正错误、提醒。再次申明ex.printStackTrace()算不上已经“处理好了异常”.

       2、重新抛出异常。既然你认为你没有能力处理该异常，那么你就尽情向上抛吧！！！

       3、封装异常。这是LZ认为最好的处理方法，对异常信息进行分类，然后进行封装处理。

       4、不要捕获异常。
	   
	异常使用指南（摘自：Think in java）

       应该在下列情况下使用异常。

       1、在恰当的级别处理问题（在知道该如何处理异常的情况下才捕获异常）。

       2、解决问题并且重新调用产生异常的方法。

       3、进行少许修补，然后绕过异常发生的地方继续执行。

       4、用别的数据进行计算，以代替方法预计会返回的值。

       5、把当前运行环境下能做的事情尽量做完。然后把相同（不同）的异常重新抛到更高层。

       6、终止程序。

       7、进行简化。

       8、让类库和程序更加安全。（这既是在为调试做短期投资，也是在为程序的健壮做长期投资）
	   数组的初始化。有如下三种形式：
	   int a[] = new int[2]={3,4}=new int[]{2,4}
	   
	   类加载器先看看数组类是否已经被创建了。如果没有，那就说明需要创建数组类；如果有，那就无需创建了。
		如果数组元素是引用类型，那么类加载器首先去加载数组元素的类。

		JVM根据元素类型和维度，创建相应的数组类。
通过Arrays.copyOf()方法产生的数组是一个浅拷贝。同时数组的clone()方法也是，集合的clone()方法也是

public static void main(String[] args) {  
        int[] datas = new int[]{1,2,3,4,5};  
        List list = Arrays.asList(datas);  
        System.out.println(list.size());  
    }  
------------Output:  
1 
注意这个参数:T…a，这个参数是一个泛型的变长参数，我们知道基本数据类型是不可能泛型化的

2 asList返回的是一个长度不可变的列表。数组是多长，转换成的列表是多长，我们是无法通过add、remove来增加或者减少其长度的。


对于equals，我们必须遵循如下规则：

      对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。

      反射性：x.equals(x)必须返回是“true”。

      类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。

      一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。

任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。

对于hashCode，我们应该遵循如下规则：

1. 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。

2. 如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。

3. 如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。

同一个线程在调用本类中其他synchronized方法/块或父类中的synchronized方法/块时，都不会阻碍该线程地执行，因为互斥锁时可重入的。


在Java中，可以通过配合调用Object对象的wait（）方法和notify（）方法或notifyAll（）方法来实现线程间的通信。在线程中调用wait（）方法，将阻塞等待其他线程的通知（其他线程调用notify（）方法或notifyAll（）方法），在线程中调用notify（）方法或notifyAll（）方法，将通知其他线程从wait（）方法处返回。


      Object是所有类的超类，它有5个方法组成了等待/通知机制的核心：notify（）、notifyAll（）、wait（）、wait（long）和wait（long，int）。在Java中，所有的类都从Object继承而来，因此，所有的类都拥有这些共有方法可供使用。而且，由于他们都被声明为final，因此在子类中不能覆写任何一个方法。

 

     这里详细说明一下各个方法在使用中需要注意的几点：

 

      1、wait（）

      public final void wait()  throws InterruptedException,IllegalMonitorStateException

     该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用wait（）之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法。进入wait（）方法后，当前线程释放锁。在从wait（）返回前，线程与其他线程竞争重新获得锁。如果调用wait（）时，没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。

 

     2、notify（）

     public final native void notify() throws IllegalMonitorStateException

        该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，的如果调用notify（）时没有持有适当的锁，也会抛出IllegalMonitorStateException。

     该方法用来通知那些可能等待该对象的对象锁的其他线程。如果有多个线程等待，则线程规划器任意挑选出其中一个wait（）状态的线程来发出通知，并使它等待获取该对象的对象锁（notify后，当前线程不会马上释放该对象锁，wait所在的线程并不能马上获取该对象锁，要等到程序退出synchronized代码块后，当前线程才会释放锁，wait所在的线程也才可以获取该对象锁），但不惊动其他同样在等待被该对象notify的线程们。当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。这里需要注意：它们等待的是被notify或notifyAll，而不是锁。这与下面的notifyAll（）方法执行后的情况不同。 

 

     3、notifyAll（）

     public final native void notifyAll() throws IllegalMonitorStateException

      该方法与notify（）方法的工作方式相同，重要的一点差异是：

      notifyAll使所有原来在该对象上wait的线程统统退出wait的状态（即全部被唤醒，不再等待notify或notifyAll，但由于此时还没有获取到该对象锁，因此还不能继续往下执行），变成等待获取该对象上的锁，一旦该对象锁被释放（notifyAll线程退出调用了notifyAll的synchronized代码块的时候），他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。

 

     4、wait（long）和wait（long,int）

     显然，这两个方法是设置等待超时时间的，后者在超值时间上加上ns，精度也难以达到，因此，该方法很少使用。对于前者，如果在等待线程接到通知或被中断之前，已经超过了指定的毫秒数，则它通过竞争重新获得锁，并从wait（long）返回。另外，需要知道，如果设置了超时时间，当wait（）返回时，我们不能确定它是因为接到了通知还是因为超时而返回的，因为wait（）方法不会返回任何相关的信息。但一般可以通过设置标志位来判断，在notify之前改变标志位的值，在wait（）方法后读取该标志位的值来判断，当然为了保证notify不被遗漏，我们还需要另外一个标志位来循环判断是否调用wait（）方法。

 


       深入理解：

   如果线程调用了对象的wait（）方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。

   当有线程调用了对象的notifyAll（）方法（唤醒所有wait线程）或notify（）方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。

   优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait（）方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。

   深入Java虚拟机——JVM高级特性与最佳实践
   
   this逃逸问题


